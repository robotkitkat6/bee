<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Rider ‚Äî ƒê·∫∑t xe</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="style.css" /> <style>
    .driver-icon {
      background-image: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path fill="#dc3545" d="M16 0C9.92 0 4.98 4.79 5.04 10.74c.06 5.86 4.98 10.74 10.96 10.74s10.9-4.88 10.96-10.74C27.02 4.79 22.08 0 16 0zm0 14a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"/><path fill="#dc3545" d="M15.5 22.06c-5.5.06-9.94 4.56-9.94 10a10.02 10.02 0 0 0 19.88 0c0-5.44-4.44-9.94-9.94-10z"/></svg>');
      background-size: cover;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.4);
    }
    /* ƒê·∫£m b·∫£o style.css c√≥ c√°c class c·∫ßn thi·∫øt cho UI */
  </style>
</head>
<body>
  <h2>ƒê·∫∑t xe ‚Äî Nh·∫≠p ƒë·ªãa ch·ªâ</h2>

  <label>ƒêi·ªÉm ƒë√≥n 
    <button id="currentLocationBtn" class="current-location-btn">
      [V·ªã tr√≠ hi·ªán t·∫°i]
    </button>
  </label>
  <div class="input-container">
    <input id="from" placeholder="V√≠ d·ª•: 1 Ph·ªë A, Qu·∫≠n B" />
    <ul id="fromList" class="autocomplete-list" style="display:none;"></ul>
  </div>

  <label>ƒêi·ªÉm ƒë·∫øn</label>
  <div class="input-container">
    <input id="to" placeholder="V√≠ d·ª•: 2 Ph·ªë X, Qu·∫≠n Y" />
    <ul id="toList" class="autocomplete-list" style="display:none;"></ul>
  </div>
  <label>Ch·ªçn lo·∫°i xe</label>
  <select id="vehicle">
    <option value="bike">Xe m√°y</option>
    <option value="car">√î t√¥</option>
  </select>

  <div class="row">
    <button id="estimateBtn" class="col btn btn-primary">∆Ø·ªõc t√≠nh & Hi·ªÉn th·ªã tuy·∫øn</button>
    <button id="requestBtn" class="col btn btn-secondary" disabled>G·ªçi xe (l∆∞u)</button>
    <button id="cancelBtn" class="col btn btn-danger" style="display:none;" disabled>H·ªßy chuy·∫øn</button>
  </div>

  <div id="info"></div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getDatabase, push, ref, onValue, remove } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    // C·∫•u h√¨nh Firebase (ƒê√£ ƒë·ªìng b·ªô)
    const firebaseConfig = {
      apiKey: "AIzaSyCUQpfPPlJqLRm9FyryfX2UOa82mUWbJrE",
      authDomain: "robotkitkat6-bee.firebaseapp.com",
      databaseURL: "https://robotkitkat6-bee-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "robotkitkat6-bee",
      storageBucket: "robotkitkat6-bee.firebasestorage.app",
      messagingSenderId: "117130770804",
      appId: "1:117130770804:web:4827cc61a7c9df99549421",
      measurementId: "G-WMKP4GT930"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // Map init
    const map = L.map('map').setView([10.762622, 106.660172], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    let routingControl = null;
    let lastRouteSummary = null; 
    let lastFromCoords = null; 
    let lastToCoords = null;   
    let currentRideId = null; 

    const infoDiv = document.getElementById('info');
    const estimateBtn = document.getElementById('estimateBtn');
    const requestBtn = document.getElementById('requestBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const fromInput = document.getElementById('from');
    const toInput = document.getElementById('to');
    const currentLocationBtn = document.getElementById('currentLocationBtn');
    const fromList = document.getElementById('fromList');
    const toList = document.getElementById('toList');
    
    // L∆∞u t·∫°m th·ªùi t·ªça ƒë·ªô c·ªßa g·ª£i √Ω ƒë√£ ch·ªçn
    let selectedFromCoord = null;
    let selectedToCoord = null;

    // Driver Marker Layer
    const driverMarkers = {};
    const driverIcon = L.divIcon({
        className: 'driver-icon',
        iconSize: [30, 30],
        iconAnchor: [15, 15],
        popupAnchor: [0, -15]
    });


    // Pricing
    const PRICE = { bikePerKm: 6000, carPerKm: 10000, bikeMin: 10000, carMin: 20000 };
    
    // ==========================================================
    // === CH·ª®C NƒÇNG 1: GEOLOCATION V√Ä REVERSE GEOCODE ===
    // ==========================================================

    // Reverse Geocode (t·ª´ t·ªça ƒë·ªô ra t√™n ƒë·ªãa ƒëi·ªÉm)
    async function reverseGeocode(lat, lng) {
        const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=vi`;
        const res = await fetch(url);
        const data = await res.json();
        if (data && data.display_name) {
             return { 
                lat: parseFloat(data.lat), 
                lng: parseFloat(data.lon), 
                display: data.display_name 
            };
        }
        throw new Error('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ cho t·ªça ƒë·ªô n√†y.');
    }

    currentLocationBtn.addEventListener('click', () => {
        infoDiv.innerHTML = 'ƒêang t√¨m v·ªã tr√≠ hi·ªán t·∫°i...';
        currentLocationBtn.disabled = true;

        if (!navigator.geolocation) {
            alert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ƒê·ªãnh v·ªã.');
            currentLocationBtn.disabled = false;
            infoDiv.innerHTML = '';
            return;
        }

        navigator.geolocation.getCurrentPosition(async (position) => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            
            try {
                const result = await reverseGeocode(lat, lng);
                fromInput.value = result.display;
                selectedFromCoord = { lat, lng }; // L∆∞u t·ªça ƒë·ªô ƒë√£ ƒë·ªãnh v·ªã
                infoDiv.innerHTML = `<div>ƒê√£ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i: ${result.display}</div>`;
            } catch(e) {
                 infoDiv.innerHTML = `<div>L·ªói l·∫•y ƒë·ªãa ch·ªâ: ${e.message}</div>`;
            } finally {
                currentLocationBtn.disabled = false;
            }
        }, (error) => {
            infoDiv.innerHTML = `<div>L·ªói ƒê·ªãnh v·ªã: ${error.message}</div>`;
            currentLocationBtn.disabled = false;
        }, { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 });
    });


    // ==========================================================
    // === CH·ª®C NƒÇNG 2: GEOLOCATION AUTOSUGGEST ===
    // ==========================================================

    // Debounce function ƒë·ªÉ tr√°nh g·ªçi API qu√° nhi·ªÅu l·∫ßn
    const debounce = (func, delay) => {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    };

    // Geocode via Nominatim
    async function geocode(q) {
      const url = 'https://nominatim.openstreetmap.org/search?format=json&q=' + encodeURIComponent(q) + '&limit=10&accept-language=vi';
      const res = await fetch(url, { headers: { 'Accept-Language': 'vi' } });
      const arr = await res.json();
      if (!arr || !arr.length) throw new Error('Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm: ' + q);
      return { lat: parseFloat(arr[0].lat), lng: parseFloat(arr[0].lon), display: arr[0].display_name };
    }
    
    // H√†m t√¨m ki·∫øm v√† hi·ªÉn th·ªã g·ª£i √Ω
    async function fetchSuggestions(query, targetList, targetInput) {
        if (query.length < 3) {
            targetList.style.display = 'none';
            return;
        }

        try {
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&countrycodes=vn&accept-language=vi`;
            const res = await fetch(url);
            const data = await res.json();
            
            targetList.innerHTML = '';
            
            if (data.length === 0) {
                 targetList.style.display = 'none';
                 return;
            }

            data.forEach(item => {
                const li = document.createElement('li');
                li.textContent = item.display_name;
                li.dataset.lat = item.lat;
                li.dataset.lng = item.lon;
                
                // G·∫Øn s·ª± ki·ªán click
                li.addEventListener('click', () => {
                    targetInput.value = item.display_name;
                    if (targetInput.id === 'from') {
                        selectedFromCoord = { lat: parseFloat(item.lat), lng: parseFloat(item.lon) };
                    } else {
                        selectedToCoord = { lat: parseFloat(item.lat), lng: parseFloat(item.lon) };
                    }
                    targetList.style.display = 'none';
                    // T·ª± ƒë·ªông g·ªçi Estimate n·∫øu c·∫£ 2 ƒë√£ c√≥ ƒë·ªãa ch·ªâ
                    if (selectedFromCoord && selectedToCoord) {
                        estimateBtn.click();
                    }
                });
                targetList.appendChild(li);
            });
            targetList.style.display = 'block';

        } catch (error) {
            console.error('L·ªói g·ª£i √Ω ƒë·ªãa ch·ªâ:', error);
            targetList.style.display = 'none';
        }
    }

    // Thi·∫øt l·∫≠p Debounce cho c·∫£ 2 √¥ input
    const debouncedFromSuggest = debounce((query) => fetchSuggestions(query, fromList, fromInput), 400);
    const debouncedToSuggest = debounce((query) => fetchSuggestions(query, toList, toInput), 400);

    fromInput.addEventListener('input', (e) => {
        selectedFromCoord = null; // X√≥a t·ªça ƒë·ªô ƒë√£ ch·ªçn khi g√µ l·∫°i
        debouncedFromSuggest(e.target.value.trim());
    });
    toInput.addEventListener('input', (e) => {
        selectedToCoord = null; // X√≥a t·ªça ƒë·ªô ƒë√£ ch·ªçn khi g√µ l·∫°i
        debouncedToSuggest(e.target.value.trim());
    });

    // ·∫®n danh s√°ch g·ª£i √Ω khi click ra ngo√†i
    document.addEventListener('click', (e) => {
        if (!fromInput.parentElement.contains(e.target)) fromList.style.display = 'none';
        if (!toInput.parentElement.contains(e.target)) toList.style.display = 'none';
    });


    // ==========================================================
    // === CH·ª®C NƒÇNG 3: HI·ªÇN TH·ªä T√ÄI X·∫æ XUNG QUANH ===
    // ==========================================================
    
    function initDriverListener() {
        const driversRef = ref(db, 'drivers');

        onValue(driversRef, (snapshot) => {
            const drivers = snapshot.val() || {};
            const activeDriverIds = new Set();
            
            // C·∫≠p nh·∫≠t/Th√™m marker cho t√†i x·∫ø ƒëang online
            Object.keys(drivers).forEach(driverId => {
                const d = drivers[driverId];
                activeDriverIds.add(driverId);
                
                if (d.online && d.lat && d.lng) {
                    const latLng = [d.lat, d.lng];
                    const name = d.name || 'T√†i x·∫ø ·∫©n danh';
                    
                    if (driverMarkers[driverId]) {
                        // Di chuy·ªÉn marker n·∫øu ƒë√£ t·ªìn t·∫°i
                        driverMarkers[driverId].setLatLng(latLng);
                        driverMarkers[driverId].setPopupContent(`<b>${name}</b> ƒëang Online`);
                    } else {
                        // T·∫°o marker m·ªõi
                        const marker = L.marker(latLng, { icon: driverIcon }).addTo(map);
                        marker.bindPopup(`<b>${name}</b> ƒëang Online`);
                        driverMarkers[driverId] = marker;
                    }
                }
            });

            // X√≥a marker c·ªßa t√†i x·∫ø ƒë√£ offline
            Object.keys(driverMarkers).forEach(driverId => {
                if (!activeDriverIds.has(driverId)) {
                    map.removeLayer(driverMarkers[driverId]);
                    delete driverMarkers[driverId];
                }
            });
        });
    }

    // G·ªçi h√†m kh·ªüi t·∫°o l·∫Øng nghe t√†i x·∫ø ngay khi script ch·∫°y
    initDriverListener();


    // ==========================================================
    // === LOGIC CH√çNH (ƒê·∫∂T V√Ä H·ª¶Y CHUY·∫æN) ===
    // ==========================================================

    // Estimate route using Leaflet Routing Machine
    function showRoute(fromCoords, toCoords) {
      if (routingControl) { map.removeControl(routingControl); routingControl = null; lastRouteSummary = null; }
      routingControl = L.Routing.control({
        waypoints: [
          L.latLng(fromCoords.lat, fromCoords.lng),
          L.latLng(toCoords.lat, toCoords.lng)
        ],
        router: L.Routing.osrmv1({serviceUrl: 'https://router.project-osrm.org/route/v1'}),
        addWaypoints: false,
        draggableWaypoints: false,
        fitSelectedRoutes: true,
        showAlternatives: false
      }).addTo(map);

      routingControl.on('routesfound', function(e) {
        const route = e.routes[0];
        lastRouteSummary = { distance: route.summary.totalDistance, duration: route.summary.totalTime };
        displayInfo();
        requestBtn.disabled = false;
        // C·∫≠p nh·∫≠t lastFromCoords v√† lastToCoords b·∫±ng t·ªça ƒë·ªô th·ª±c c·ªßa tuy·∫øn ƒë∆∞·ªùng
        lastFromCoords = { lat: e.routes[0].waypoints[0].latLng.lat, lng: e.routes[0].waypoints[0].latLng.lng };
        lastToCoords = { lat: e.routes[0].waypoints[1].latLng.lat, lng: e.routes[0].waypoints[1].latLng.lng };
      });

      routingControl.on('routingerror', function(e) {
         lastRouteSummary = null;
         requestBtn.disabled = true;
         infoDiv.innerHTML = `<div><b>L·ªói:</b> Kh√¥ng t√¨m th·∫•y tuy·∫øn ƒë∆∞·ªùng.</div>`;
      });
    }

    function displayInfo() {
      // Logic t√≠nh gi√° ti·ªÅn gi·ªØ nguy√™n...
      if (!lastRouteSummary) return;
      const km = (lastRouteSummary.distance / 1000);
      const mins = Math.round(lastRouteSummary.duration / 60);
      const vehicle = document.getElementById('vehicle').value;
      let priceCalc = 0;
      if (vehicle === 'bike') {
        priceCalc = Math.max(Math.round(km * PRICE.bikePerKm), PRICE.bikeMin);
      } else {
        priceCalc = Math.max(Math.round(km * PRICE.carPerKm), PRICE.carMin);
      }
      infoDiv.innerHTML = `
        <div><b>Kho·∫£ng c√°ch:</b> ${km.toFixed(2)} km</div>
        <div><b>Th·ªùi gian d·ª± ki·∫øn:</b> ${mins} ph√∫t</div>
        <div><b>Lo·∫°i xe:</b> ${vehicle === 'bike' ? 'Xe m√°y' : '√î t√¥'}</div>
        <div><b>Gi√° ∆∞·ªõc t√≠nh:</b> ${priceCalc.toLocaleString()} ƒë</div>
      `;
    }
    
    function listenForAcceptance(rideId) {
        // Logic l·∫Øng nghe tr·∫°ng th√°i gi·ªØ nguy√™n...
        const rideRef = ref(db, 'rides/' + rideId);
        onValue(rideRef, (snap) => {
            const ride = snap.val();
            
            if (!ride) {
                 if (currentRideId === rideId) {
                     infoDiv.innerHTML = `<div style="color:var(--secondary-color); font-weight: bold; margin-top: 10px;">Cu·ªëc xe ƒë√£ k·∫øt th√∫c/b·ªã h·ªßy.</div>`;
                     cancelBtn.style.display = 'none';
                     requestBtn.disabled = false;
                     currentRideId = null;
                 }
                 return;
            }

            const driverName = ride.driverName || 'T√†i x·∫ø';

            if (ride.status === 'accepted') {
                infoDiv.innerHTML = `
                    <div style="color:var(--primary-color); font-weight: bold; font-size: 1.2em;">‚úÖ T√ÄI X·∫æ ƒê√É NH·∫¨N CU·ªêC!</div>
                    <div>T√†i x·∫ø <b>${driverName}</b> ƒëang ƒë·∫øn ƒë√≥n b·∫°n.</div>
                `;
            } else if (ride.status === 'onTrip') {
                infoDiv.innerHTML = `
                    <div style="color:var(--success-color); font-weight: bold; font-size: 1.2em;">üöó B·∫ÆT ƒê·∫¶U H√ÄNH TR√åNH!</div>
                    <div>B·∫°n ƒëang tr√™n ƒë∆∞·ªùng ƒë·∫øn ƒëi·ªÉm ƒë·∫øn c√πng t√†i x·∫ø <b>${driverName}</b>.</div>
                `;
            } else if (ride.status === 'finding') {
                if (!infoDiv.innerHTML.includes('ƒêang t√¨m t√†i x·∫ø')) {
                    infoDiv.innerHTML += `<div style="color:var(--success-color); margin-top: 10px;">Y√™u c·∫ßu ƒë√£ g·ª≠i (ID: ${rideId}). ƒêang t√¨m t√†i x·∫ø...</div>`;
                }
            }
            
            if (ride.status !== 'completed' && ride.status !== 'canceled') {
                cancelBtn.style.display = 'inline-block';
                cancelBtn.disabled = false;
            }

        });
    }

    // Button: Estimate (ƒê√£ s·ª≠a ƒë·ªÉ d√πng t·ªça ƒë·ªô t·ª´ Autocomplete/Current Location)
    estimateBtn.addEventListener('click', async () => {
      const from = fromInput.value.trim();
      const to = toInput.value.trim();
      if (!from || !to) return alert('Nh·∫≠p ƒëi·ªÉm ƒë√≥n v√† ƒëi·ªÉm ƒë·∫øn');
      
      try {
        estimateBtn.disabled = true;
        requestBtn.disabled = true;
        infoDiv.innerHTML = 'ƒêang t√¨m ƒë·ªãa ch·ªâ...';
        cancelBtn.style.display = 'none';

        let fromCoords, toCoords;

        // ∆Øu ti√™n d√πng t·ªça ƒë·ªô ƒë√£ ch·ªçn t·ª´ Current Location ho·∫∑c Autocomplete
        if (selectedFromCoord) {
            fromCoords = selectedFromCoord;
        } else {
             // Fallback: Geocode l·∫ßn cu·ªëi n·∫øu ng∆∞·ªùi d√πng ch·ªâ g√µ m√† ch∆∞a click suggest
             fromCoords = await geocode(from);
        }
        
        if (selectedToCoord) {
            toCoords = selectedToCoord;
        } else {
             toCoords = await geocode(to);
        }

        showRoute(fromCoords, toCoords);
        // lastFromCoords, lastToCoords s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong showRoute.on('routesfound')

      } catch (e) {
        alert(e.message || 'L·ªói khi geocode/t√¨m tuy·∫øn ƒë∆∞·ªùng');
        infoDiv.innerHTML = '';
        lastRouteSummary = null;
        lastFromCoords = null;
        lastToCoords = null;
      } finally {
        estimateBtn.disabled = false;
      }
    });

    // Button: Request (Gi·ªØ nguy√™n logic)
    requestBtn.addEventListener('click', async () => {
      if (!lastRouteSummary || !lastFromCoords || !lastToCoords) {
        return alert('Vui l√≤ng nh·∫•n "∆Ø·ªõc t√≠nh & Hi·ªÉn th·ªã tuy·∫øn" tr∆∞·ªõc v√† ƒë·∫£m b·∫£o t√¨m th·∫•y tuy·∫øn ƒë∆∞·ªùng.');
      }
      
      const from = fromInput.value.trim();
      const to = toInput.value.trim();
      const vehicle = document.getElementById('vehicle').value;
      const km = lastRouteSummary.distance / 1000;
      const mins = Math.round(lastRouteSummary.duration / 60);

      let fare = 0;
      if (vehicle === 'bike') fare = Math.max(Math.round(km * PRICE.bikePerKm), PRICE.bikeMin);
      else fare = Math.max(Math.round(km * PRICE.carPerKm), PRICE.carMin);

      const ride = {
        createdAt: Date.now(),
        status: 'finding',
        fromText: from,
        toText: to,
        from: lastFromCoords, // D√πng t·ªça ƒë·ªô ƒë√£ ƒë∆∞·ª£c Routing Machine x√°c nh·∫≠n
        to: lastToCoords, 
        distance_m: lastRouteSummary.distance,
        duration_s: lastRouteSummary.duration,
        distance_km: km,
        duration_min: mins,
        fare: fare,
        vehicle: vehicle
      };

      try {
        const ridesRef = ref(db, 'rides');
        const newRef = await push(ridesRef, ride);
        const rideId = newRef.key;

        currentRideId = rideId; 
        listenForAcceptance(rideId);
        
        requestBtn.disabled = true;

      } catch (e) {
        alert('L·ªói g·ª≠i y√™u c·∫ßu: ' + (e.message || e));
      }
    });

    // N√öT H·ª¶Y CHUY·∫æN (Gi·ªØ nguy√™n logic)
    cancelBtn.addEventListener('click', async () => {
        if (!currentRideId) return;

        const isAccepted = infoDiv.innerHTML.includes('T√ÄI X·∫æ ƒê√É NH·∫¨N CU·ªêC') || infoDiv.innerHTML.includes('B·∫ÆT ƒê·∫¶U H√ÄNH TR√åNH');
        let confirmationMsg = "B·∫°n ch·∫Øc ch·∫Øn mu·ªën h·ªßy chuy·∫øn n√†y?";
        if (isAccepted) {
            confirmationMsg = "T√†i x·∫ø ƒë√£ nh·∫≠n cu·ªëc/ƒë√£ ƒë√≥n kh√°ch. Vi·ªác h·ªßy c√≥ th·ªÉ b·ªã t√≠nh ph√≠. B·∫°n ch·∫Øc ch·∫Øn mu·ªën h·ªßy?";
        }

        if (!confirm(confirmationMsg)) return;

        try {
            const rideRef = ref(db, 'rides/' + currentRideId);
            await remove(rideRef); 

            infoDiv.innerHTML = '<div style="color:var(--danger-color); font-weight: bold; margin-top: 10px;">‚ùå ƒê√É H·ª¶Y CHUY·∫æN.</div>';
            
            // Reset UI
            currentRideId = null;
            requestBtn.disabled = false;
            cancelBtn.style.display = 'none';
            
            if (routingControl) { map.removeControl(routingControl); routingControl = null; lastRouteSummary = null; }

        } catch (e) {
            alert('L·ªói h·ªßy chuy·∫øn: ' + (e.message || e));
        }
    });
  </script>
</body>
</html>
