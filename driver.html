<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Driver ‚Äî Nh·∫≠n cu·ªëc</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="style.css" /> 
</head>
<body>
  <div class="map-page-container">
    <div id="map"></div>
    
    <div id="statusControl" class="overlay-card">
        <h2>Thi·∫øt l·∫≠p T√†i x·∫ø</h2>
        
        <div id="driverNameInput">
            <label>T√™n & Bi·ªÉn s·ªë xe</label>
            <input id="driverName" placeholder="V√≠ d·ª•: Nam H·∫£i - 29L1-33254"/>
        </div>

        <div id="driverInfo" style="font-weight: bold; margin-bottom: 10px;">Ch∆∞a online</div>
        
        <div class="row" style="margin-top: 5px;">
            <button id="goOnline" class="btn btn-success col">B·∫≠t Online</button>
            <button id="goOffline" class="btn btn-danger col" style="display:none">T·∫Øt Online</button>
        </div>
    </div>

    <div id="activeRideOverlay" class="overlay-card" style="display:none; transition: all 0.3s ease-in-out; bottom: 15px;">
        </div>

    <div id="newRidesList" style="position: absolute; top: 15px; right: 15px; z-index: 20; max-height: 50vh; overflow-y: auto;">
        </div>
  </div>


  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getDatabase, ref, set, remove, onChildAdded, onChildChanged,
      onValue, update, push
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    // C·∫•u h√¨nh Firebase (Gi·ªØ nguy√™n)
    const firebaseConfig = {
      apiKey: "AIzaSyCUQpfPPlJqLRm9FyryfX2UOa82mUWbJrE",
      authDomain: "robotkitkat6-bee.firebaseapp.com",
      databaseURL: "https://robotkitkat6-bee-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "robotkitkat6-bee",
      storageBucket: "robotkitkat6-bee.firebasestorage.app",
      messagingSenderId: "117130770804",
      appId: "1:117130770804:web:4827cc61a7c9df99549421",
      measurementId: "G-WMKP4GT930"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // Map init (Gi·ªØ nguy√™n)
    const map = L.map('map').setView([10.762622, 106.660172], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    let driverMarker = L.marker([10.762622, 106.660172], { draggable:true }).addTo(map);
    driverMarker.bindPopup('B·∫°n (t√†i x·∫ø)').openPopup();

    const DRIVER_ID_KEY = 'driverUniqueId';
    let DRIVER_ID = localStorage.getItem(DRIVER_ID_KEY);
    if (!DRIVER_ID) {
      DRIVER_ID = 'driver_' + Date.now() + '_' + Math.floor(Math.random()*9999);
      localStorage.setItem(DRIVER_ID_KEY, DRIVER_ID);
    }
    
    let lastPos = null;
    let online = false;
    let watchId = null;

    const newRidesList = document.getElementById('newRidesList'); 
    const activeRideOverlay = document.getElementById('activeRideOverlay'); 
    const statusControl = document.getElementById('statusControl');
    const driverNameInput = document.getElementById('driverName');

    let shownRides = {}; 

    const STORAGE_KEY_STATUS = 'driverOnlineStatus';
    const STORAGE_KEY_NAME = 'driverName';

    // === H√ÄM PH√ÅT √ÇM THANH V√Ä RUNG ===
    function notifyNewRide() {
        if (navigator.vibrate) {
            navigator.vibrate([500, 250, 500]); // Rung 2 l·∫ßn
        }
        try {
            const audio = new Audio('https://www.soundjay.com/buttons/beep-07a.mp3'); // √Çm thanh nh·∫π nh√†ng
            audio.play();
        } catch (e) {
            console.warn('Kh√¥ng th·ªÉ ph√°t √¢m thanh:', e);
        }
    }
    // ===========================================

    function saveDriverState(isOnline, name) {
        localStorage.setItem(STORAGE_KEY_STATUS, isOnline ? 'online' : 'offline');
        localStorage.setItem(STORAGE_KEY_NAME, name);
    }

    function loadDriverState() {
        const savedName = localStorage.getItem(STORAGE_KEY_NAME);
        if (savedName) {
            driverNameInput.value = savedName;
        }
        const savedStatus = localStorage.getItem(STORAGE_KEY_STATUS);
        if (savedStatus === 'online') {
            document.getElementById('goOnline').click();
        }
    }

    const driversRef = ref(db, 'drivers');
    const ridesRef = ref(db, 'rides');

    // S·ª¨A: C·∫≠p nh·∫≠t giao di·ªán sau khi Online
    async function setDriverOnline(name, lat, lng) {
      const dRef = ref(db, 'drivers/' + DRIVER_ID);
      await set(dRef, { id: DRIVER_ID, name, lat, lng, online: true, updatedAt: Date.now() });
      
      // C·∫≠p nh·∫≠t giao di·ªán (nh·ªè l·∫°i)
      statusControl.classList.add('small');
      document.getElementById('driverInfo').innerText = `${name} | üü¢ Online`;
      document.getElementById('goOnline').style.display = 'none';
      document.getElementById('goOffline').style.display = 'inline-block';
      document.getElementById('driverNameInput').style.display = 'none'; 
    }
    
    async function setDriverOffline() {
      const dRef = ref(db, 'drivers/' + DRIVER_ID);
      await remove(dRef).catch(()=>{});

      // C·∫≠p nh·∫≠t giao di·ªán (tr·ªü l·∫°i l·ªõn)
      statusControl.classList.remove('small');
      document.getElementById('driverInfo').innerText = 'B·∫°n ƒë√£ offline';
      document.getElementById('goOnline').style.display = 'inline-block';
      document.getElementById('goOffline').style.display = 'none';
      document.getElementById('driverNameInput').style.display = 'block';
    }
    
    async function updateDriverLocation(lat, lng) {
        lastPos = { lat, lng };
        driverMarker.setLatLng([lat,lng]);
        map.panTo([lat,lng]);
        const dRef = ref(db, 'drivers/' + DRIVER_ID);
        await update(dRef, { lat, lng, updatedAt: Date.now() }).catch(()=>{});
        
        Object.keys(shownRides).forEach(rideId => {
            const s = shownRides[rideId];
            if (s.accepted) { 
                const rideRef = ref(db, 'rides/' + rideId);
                update(rideRef, { driverLat: lat, driverLng: lng });
                if (s.routeControl) {
                    const waypoints = s.routeControl.getWaypoints();
                    if (waypoints.length > 0) {
                        waypoints[0].latLng = L.latLng(lat, lng);
                        s.routeControl.setWaypoints(waypoints);
                    }
                }
            }
        });
    }

    function startWatch() {
      if (!navigator.geolocation) { alert('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã'); return; }
      navigator.geolocation.getCurrentPosition(async (p) => {
        await updateDriverLocation(p.coords.latitude, p.coords.longitude);
      }, ()=>{}, { enableHighAccuracy:true });
      
      watchId = navigator.geolocation.watchPosition(async (p) => {
        await updateDriverLocation(p.coords.latitude, p.coords.longitude);
      }, (err)=>console.warn(err), { enableHighAccuracy:true, maximumAge:2000, timeout:10000 });
    }
    function stopWatch() { if (watchId) navigator.geolocation.clearWatch(watchId); watchId = null; }

    // FETCH RIDES 
    onChildAdded(ridesRef, (snap) => {
      const ride = snap.val(); const rideId = snap.key;
      if (!online || !ride) return;
      if (!lastPos) return; 
      checkAndShowRide(rideId, ride);
    });

    onChildChanged(ridesRef, (snap) => {
      const ride = snap.val(); const rideId = snap.key;
      if (!online || !ride) return;
      
      if (ride.status !== 'finding' && ride.driverId !== DRIVER_ID) {
        removeRideFromUI(rideId);
        return;
      }
      if (lastPos) checkAndShowRide(rideId, ride);
    });

    function checkAndShowRide(rideId, rideObj) {
        if (!rideObj.from) return;
        const driverPt = turf.point([lastPos.lng, lastPos.lat]);
        const pickupPt = turf.point([rideObj.from.lng, rideObj.from.lat]);
        const d = turf.distance(driverPt, pickupPt, { units: 'kilometers' });
        
        const isFindingAndNear = (rideObj.status === 'finding' && d <= 3);
        const isAcceptedByMe = (rideObj.driverId === DRIVER_ID && (rideObj.status === 'accepted' || rideObj.status === 'onTrip'));
        
        if (isFindingAndNear) {
            // Cu·ªëc m·ªõi ƒë·∫øn
            if (!shownRides[rideId]) {
                createRideUI(rideId, rideObj, d);
                notifyNewRide(); // PH√ÅT √ÇM THANH & RUNG
            }
            updateRideUI(rideId, rideObj, d);
        } else if (isAcceptedByMe) {
            // Cu·ªëc ƒë√£ nh·∫≠n
            if (!shownRides[rideId]) {
                createRideUI(rideId, rideObj, d, true); 
            }
            updateRideUI(rideId, rideObj, d);
            newRidesList.style.display = 'none'; // ·∫®n danh s√°ch cu·ªëc m·ªõi
        } else {
            removeRideFromUI(rideId);
        }
    }

    // S·ª¨A: D√πng class m·ªõi cho cu·ªëc m·ªõi (new-request-card)
    function createRideUI(rideId, rideObj, distKm, isActive = false) {
      const el = document.createElement('div');
      el.className = isActive ? 'active-request' : 'new-request-card';
      el.id = 'ride_' + rideId;
      
      el.dataset.fromLat = rideObj.from.lat; 
      el.dataset.fromLng = rideObj.from.lng;
      el.dataset.toLat = rideObj.to.lat;
      el.dataset.toLng = rideObj.to.lng;

      const pickup = `${rideObj.fromText || '‚Äî'}`;
      const dest = `${rideObj.toText || '‚Äî'}`;
      el.innerHTML = `
        <h3>Cu·ªëc xe #${rideId.slice(-4)} (${rideObj.vehicle === 'bike' ? 'Xe m√°y' : '√î t√¥'})</h3>
        <div class="distance-info">
            <span style="color: #6c757d;">C√°ch b·∫°n: </span>${distKm.toFixed(2)} km
        </div>
        <div style="margin: 5px 0; font-size: 0.9em;">
            <span style="color: #adb5bd;">ƒê√≥n:</span> ${pickup.split(',').slice(0, 2).join(',')}
        </div>
        <div style="margin: 5px 0; font-size: 0.9em;">
            <span style="color: #adb5bd;">ƒê·∫øn:</span> ${dest.split(',').slice(0, 2).join(',')}
        </div>
        <div style="margin: 5px 0; font-size: 1.1em; font-weight: bold; color: #ffc107;">
            Gi√°: ${rideObj.fare ? rideObj.fare.toLocaleString() + ' ƒë' : '‚Äî'}
        </div>
        <div class="row request-actions" style="margin-top: 10px;"></div>
      `;
      
      if (isActive) {
          activeRideOverlay.innerHTML = '';
          activeRideOverlay.appendChild(el);
          activeRideOverlay.style.display = 'block';
      } else {
          newRidesList.prepend(el);
          newRidesList.style.display = 'block';
      }
      shownRides[rideId] = { el, routeControl: null, accepted:isActive, currentStatus: rideObj.status };
    }

    function removeRideFromUI(rideId) {
      const s = shownRides[rideId];
      if (!s) return;
      if (s.routeControl) { try { map.removeControl(s.routeControl); } catch(e){} }
      if (s.el) s.el.remove();
      delete shownRides[rideId];
      
      if (activeRideOverlay.children.length === 0) {
          activeRideOverlay.style.display = 'none';
          newRidesList.style.display = 'block'; 
      }
      if (newRidesList.children.length === 0) {
          newRidesList.style.display = 'none';
      }
    }

    function updateRideUI(rideId, rideObj, distKm) {
        const s = shownRides[rideId];
        if (!s) return; 

        const distEl = s.el.querySelector('.distance-info');
        if (distEl) distEl.innerHTML = `<span style="color: #6c757d;">C√°ch b·∫°n: </span>${distKm.toFixed(2)} km`;
        
        const actionsDiv = s.el.querySelector('.request-actions');
        
        // --- LOGIC CU·ªêC M·ªöI (finding) ---
        if (rideObj.status === 'finding' && !s.accepted) {
            if (s.el.parentElement.id !== 'newRidesList') {
                removeRideFromUI(rideId);
                createRideUI(rideId, rideObj, distKm, false);
                return;
            }

            actionsDiv.innerHTML = '';
            const acceptBtn = document.createElement('button');
            acceptBtn.className = 'btn btn-accept col'; 
            acceptBtn.innerText = 'NH·∫¨N CU·ªêC';
            acceptBtn.onclick = () => acceptRide(rideId, rideObj, s.el);
            actionsDiv.appendChild(acceptBtn);
            
            if (s.routeControl) { map.removeControl(s.routeControl); s.routeControl = null; }
            return;
        } 
        
        // --- LOGIC CU·ªêC ƒê√É NH·∫¨N (accepted/onTrip) ---
        if (rideObj.driverId === DRIVER_ID && (rideObj.status === 'accepted' || rideObj.status === 'onTrip')) {
            if (s.el.parentElement.id !== 'activeRideOverlay') {
                 s.el.remove();
                 createRideUI(rideId, rideObj, distKm, true);
                 const newS = shownRides[rideId]; 
                 newS.currentStatus = ''; 
                 updateRideUI(rideId, rideObj, distKm);
                 return;
            }
            
            if (s.currentStatus === rideObj.status && s.accepted) return; 

            s.accepted = true;
            s.currentStatus = rideObj.status;
            actionsDiv.innerHTML = '';
            
            const fromLat = parseFloat(s.el.dataset.fromLat);
            const fromLng = parseFloat(s.el.dataset.fromLng);
            const toLat = parseFloat(s.el.dataset.toLat);
            const toLng = parseFloat(s.el.dataset.toLng);
            const pickup = [fromLat, fromLng];
            const dest = [toLat, toLng];

            // 1. N√∫t th√¥ng b√°o tr·∫°ng th√°i
            const statusText = rideObj.status === 'accepted' ? 'ƒêang ch·∫°y ƒë·∫øn ƒë√≥n kh√°ch' : 'ƒêANG TR√äN ƒê∆Ø·ªúNG';
            s.el.querySelector('h3').innerHTML = `<span style="color:var(--success-color);">${statusText}</span>`;
            
            // 2. N√∫t h√†nh ƒë·ªông ch√≠nh
            let actionBtn;
            if (rideObj.status === 'accepted') {
                actionBtn = document.createElement('button');
                actionBtn.className = 'btn btn-primary col';
                actionBtn.innerText = 'ƒê√É ƒê√ìN KH√ÅCH (Start Trip)';
                actionBtn.onclick = () => startTrip(rideId, s.el);
            } else if (rideObj.status === 'onTrip') {
                actionBtn = document.createElement('button');
                actionBtn.className = 'btn btn-complete col';
                actionBtn.innerText = 'HO√ÄN TH√ÄNH CU·ªêC';
                actionBtn.onclick = () => completeRide(rideId, s.el);
            }

            // 3. N√∫t H·ªßy cu·ªëc
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn btn-danger col';
            cancelBtn.innerText = 'H·ª¶Y CU·ªêC';
            cancelBtn.onclick = () => cancelRide(rideId, s.el);
            
            actionsDiv.appendChild(actionBtn);
            actionsDiv.appendChild(cancelBtn);
            
            // V·∫Ω/C·∫≠p nh·∫≠t Route
            if (s.routeControl) { map.removeControl(s.routeControl); s.routeControl = null; }

            let waypoints;
            if (rideObj.status === 'accepted') {
                waypoints = [ L.latLng(lastPos.lat, lastPos.lng), L.latLng(pickup[0], pickup[1]), L.latLng(dest[0], dest[1]) ]; 
            } else if (rideObj.status === 'onTrip') {
                waypoints = [ L.latLng(lastPos.lat, lastPos.lng), L.latLng(dest[0], dest[1]) ]; 
            }

            s.routeControl = L.Routing.control({
                waypoints,
                router: L.Routing.osrmv1({serviceUrl: 'https://router.project-osrm.org/route/v1'}),
                fitSelectedRoutes: true,
                addWaypoints: false,
                showAlternatives: false,
                lineOptions: { styles: [{ color: '#007bff', weight: 6, opacity: 0.7 }] } 
            }).addTo(map);

             if (s.routeControl && s.routeControl.getPlan() && s.routeControl.getPlan().setWaypoints) {
                s.routeControl.route(); 
             }
        }
    }
    
    // ... (Gi·ªØ nguy√™n c√°c h√†m startTrip, cancelRide, acceptRide, completeRide) ...
    async function startTrip(rideId, el) {
        if (!confirm("X√°c nh·∫≠n b·∫°n ƒë√£ ƒë√≥n kh√°ch v√† b·∫Øt ƒë·∫ßu h√†nh tr√¨nh ƒë·∫øn ƒëi·ªÉm ƒë·∫øn?")) return;
        try {
            const rideRef = ref(db, 'rides/' + rideId);
            await update(rideRef, { status: 'onTrip', startedTripAt: Date.now() });
        } catch (e) { alert('L·ªói khi b·∫Øt ƒë·∫ßu h√†nh tr√¨nh: ' + (e.message || e)); }
    }
    async function cancelRide(rideId, el) {
        if (!confirm("B·∫°n ch·∫Øc ch·∫Øn mu·ªën h·ªßy cu·ªëc xe n√†y? Vi·ªác h·ªßy s·∫Ω th√¥ng b√°o cho kh√°ch v√† x√≥a cu·ªëc xe.")) return;
        try {
            const rideRef = ref(db, 'rides/' + rideId);
            await remove(rideRef); 
            alert('ƒê√£ h·ªßy cu·ªëc xe: ' + rideId);
            removeRideFromUI(rideId);
        } catch (e) { alert('L·ªói h·ªßy chuy·∫øn: ' + (e.message || e)); }
    }
    async function acceptRide(rideId, rideObj, el) {
      const rideRef = ref(db, 'rides/' + rideId);
      onValue(rideRef, async (snap) => {
        const current = snap.val();
        if (!current) { alert('Cu·ªëc ƒë√£ b·ªã h·ªßy'); removeRideFromUI(rideId); return; }
        if (current.status && current.status !== 'finding') { alert('Cu·ªëc ƒë√£ ƒë∆∞·ª£c nh·∫≠n b·ªüi ng∆∞·ªùi kh√°c'); removeRideFromUI(rideId); return; }

        const driverName = driverNameInput.value || ('T√†i x·∫ø_' + DRIVER_ID.slice(-4));
        await update(rideRef, {
          status: 'accepted',
          driverId: DRIVER_ID,
          driverName,
          driverLat: lastPos.lat,
          driverLng: lastPos.lng,
          acceptedAt: Date.now()
        });
      }, { onlyOnce: true });
    }
    async function completeRide(rideId, el) {
      if (!confirm("X√°c nh·∫≠n ƒë√£ ho√†n th√†nh cu·ªëc xe?")) return;
      const rideRef = ref(db, 'rides/' + rideId);
      onValue(rideRef, async (snap) => {
        const current = snap.val();
        if (!current) { alert('Cu·ªëc kh√¥ng t·ªìn t·∫°i'); removeRideFromUI(rideId); return; }
        const historyRef = ref(db, 'history');
        const entry = {
          ...current,
          completedAt: Date.now(),
          completedBy: DRIVER_ID
        };
        await push(historyRef, entry);
        await remove(rideRef).catch(()=>{});
        alert('ƒê√£ ho√†n th√†nh cu·ªëc: ' + rideId);
        removeRideFromUI(rideId);
      }, { onlyOnce: true });
    }
    
    // --- BUTTON HANDLERS ---
    document.getElementById('goOnline').addEventListener('click', async () => {
      const name = driverNameInput.value || ('T√†i x·∫ø_' + DRIVER_ID.slice(-4));
      if (name.length < 5) {
          alert("Vui l√≤ng nh·∫≠p T√™n v√† Bi·ªÉn s·ªë xe ƒë·ªÉ Online.");
          return;
      }
      online = true;
      document.getElementById('driverInfo').innerText = 'K·∫øt n·ªëi...';
      startWatch();
      
      saveDriverState(true, name);

      setTimeout(async () => {
        if (!lastPos) {
          alert('Kh√¥ng l·∫•y ƒë∆∞·ª£c v·ªã tr√≠ ‚Äî ki·ªÉm tra quy·ªÅn truy c·∫≠p v·ªã tr√≠');
          online = false;
          setDriverOffline(); // T·ª± ƒë·ªông v·ªÅ Offline v√† reset UI
          saveDriverState(false, name);
          return;
        }
        await setDriverOnline(name, lastPos.lat, lastPos.lng);
      }, 900);
    });

    document.getElementById('goOffline').addEventListener('click', async () => {
      online = false;
      stopWatch();
      await setDriverOffline();
      newRidesList.innerHTML = '';
      activeRideOverlay.style.display = 'none';
      shownRides = {};
      saveDriverState(false, driverNameInput.value);
    });

    window.addEventListener('beforeunload', async () => {
      if (online) { 
        await setDriverOffline(); 
      }
    });

    loadDriverState(); 
  </script>
</body>
</html>
